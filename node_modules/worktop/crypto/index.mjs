// packages/worktop/src/crypto.ts
import { asUTF8 as o, toHEX as u } from "worktop/buffer";
function i(t, r) {
  return crypto.subtle.digest(t, o(r)).then(u);
}
var l = /* @__PURE__ */ i.bind(0, "MD5"), c = /* @__PURE__ */ i.bind(0, "SHA-1"), m = /* @__PURE__ */ i.bind(0, "SHA-256"), b = /* @__PURE__ */ i.bind(0, "SHA-384"), d = /* @__PURE__ */ i.bind(0, "SHA-512");
function g(t, r, e) {
  return crypto.subtle.importKey("raw", o(r), t, !1, e);
}
function H(t, r, e = !1) {
  return crypto.subtle.generateKey(t, e, r);
}
function A(t, r, e) {
  return crypto.subtle.sign(t, r, o(e));
}
function x(t, r, e, n) {
  return crypto.subtle.verify(t, r, n, o(e));
}
function h(t, r) {
  if (t.byteLength !== r.byteLength)
    return !1;
  let e = t.length, n = !1;
  for (; e-- > 0; )
    t[e] !== r[e] && (n = !0);
  return !n;
}
async function K(t, r, e, n, y) {
  let p = await g("PBKDF2", r, ["deriveBits"]), f = {
    name: "PBKDF2",
    salt: o(e),
    iterations: n,
    hash: t
  };
  return crypto.subtle.deriveBits(f, p, y << 3);
}
function s(t, r, e) {
  return g({ name: "HMAC", hash: t }, r, ["sign"]).then((n) => A("HMAC", n, e));
}
var S = /* @__PURE__ */ s.bind(0, "SHA-256"), P = /* @__PURE__ */ s.bind(0, "SHA-384"), C = /* @__PURE__ */ s.bind(0, "SHA-512");
export {
  s as HMAC,
  S as HMAC256,
  P as HMAC384,
  C as HMAC512,
  l as MD5,
  K as PBKDF2,
  c as SHA1,
  m as SHA256,
  b as SHA384,
  d as SHA512,
  i as digest,
  H as keygen,
  g as keyload,
  A as sign,
  h as timingSafeEqual,
  x as verify
};
