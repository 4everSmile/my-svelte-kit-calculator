// packages/worktop/src/crypto.ts
const { asUTF8:o, toHEX:u } = require('worktop/buffer');
function i(t, r) {
  return crypto.subtle.digest(t, o(r)).then(u);
}
var l = /* @__PURE__ */ i.bind(0, "MD5"), c = /* @__PURE__ */ i.bind(0, "SHA-1"), m = /* @__PURE__ */ i.bind(0, "SHA-256"), b = /* @__PURE__ */ i.bind(0, "SHA-384"), d = /* @__PURE__ */ i.bind(0, "SHA-512");
function g(t, r, e) {
  return crypto.subtle.importKey("raw", o(r), t, !1, e);
}
function H(t, r, e = !1) {
  return crypto.subtle.generateKey(t, e, r);
}
function A(t, r, e) {
  return crypto.subtle.sign(t, r, o(e));
}
function x(t, r, e, n) {
  return crypto.subtle.verify(t, r, n, o(e));
}
function h(t, r) {
  if (t.byteLength !== r.byteLength)
    return !1;
  let e = t.length, n = !1;
  for (; e-- > 0; )
    t[e] !== r[e] && (n = !0);
  return !n;
}
async function K(t, r, e, n, y) {
  let p = await g("PBKDF2", r, ["deriveBits"]), f = {
    name: "PBKDF2",
    salt: o(e),
    iterations: n,
    hash: t
  };
  return crypto.subtle.deriveBits(f, p, y << 3);
}
function s(t, r, e) {
  return g({ name: "HMAC", hash: t }, r, ["sign"]).then((n) => A("HMAC", n, e));
}
var S = /* @__PURE__ */ s.bind(0, "SHA-256"), P = /* @__PURE__ */ s.bind(0, "SHA-384"), C = /* @__PURE__ */ s.bind(0, "SHA-512");


exports.HMAC = s;
exports.HMAC256 = S;
exports.HMAC384 = P;
exports.HMAC512 = C;
exports.MD5 = l;
exports.PBKDF2 = K;
exports.SHA1 = c;
exports.SHA256 = m;
exports.SHA384 = b;
exports.SHA512 = d;
exports.digest = i;
exports.keygen = H;
exports.keyload = g;
exports.sign = A;
exports.timingSafeEqual = h;
exports.verify = x;