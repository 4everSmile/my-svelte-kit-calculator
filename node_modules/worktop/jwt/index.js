// packages/worktop/src/internal/jwt.ts
const { base64url:J, decode:H } = require('worktop/base64');
const { asBinary:I, asPEM:w, asUTF8:F, toBinary:D, toUTF8:K } = require('worktop/buffer');
const { HMAC:j, sign:W, verify:O } = require('worktop/crypto');
var u = /* @__PURE__ */ new Error("Invalid token"), C = /* @__PURE__ */ new Error("Expired token");
function B(e) {
  return J(D(F(JSON.stringify(e))));
}
function E(e) {
  return J(D(e));
}
function R(e) {
  return JSON.parse(K(I(e)));
}
function T(e) {
  let t = e.split(".");
  if (t.length !== 3)
    throw u;
  try {
    let s = H(t[1]);
    var r = R(H(t[0])), o = R(s);
  } catch (s) {
    throw u;
  }
  return {
    header: r,
    payload: o,
    signature: t[2]
  };
}
function k(e, t, r) {
  return t.iat = t.iat || Date.now() / 1e3 | 0, t.exp == null && r != null && (t.exp = t.iat + r), e + "." + B(t);
}
function A(e, t) {
  let r = T(t), o = r.payload;
  if (!t.startsWith(e + "."))
    throw u;
  if (o.exp != null && o.exp < Date.now() / 1e3)
    throw C;
  return r;
}
function v(e, t, r) {
  let { kid: o, typ: s, header: c, ...l } = r, f = {
    ...c,
    alg: e + t,
    typ: s || "JWT"
  };
  return o != null && (f.kid = o), { header: B(f), config: l };
}
function S(e, t) {
  let r, { key: o, expires: s, ...c } = t, { header: l, config: f } = v("HS", e, c);
  return r = {
    async sign(n) {
      let i = k(l, { ...f, ...n }, s), a = await j(`SHA-${e}`, o, i);
      return i + "." + E(a);
    },
    async verify(n) {
      let i = A(l, n);
      if (await r.sign(i.payload) !== n)
        throw u;
      return i.payload;
    }
  };
}
function g(e, t) {
  let { privkey: r, pubkey: o, expires: s, ...c } = t, { header: l, config: f } = v("RS", e, c), n = "RSASSA-PKCS1-v1_5", i = {
    name: "RSASSA-PKCS1-v1_5",
    hash: `SHA-${e}`
  };
  return {
    async sign(a) {
      let y = await crypto.subtle.importKey("pkcs8", w(r), i, !1, ["sign"]), p = k(l, { ...f, ...a }, s), d = await W(n, y, p);
      return p + "." + E(d);
    },
    async verify(a) {
      let [y, p, d] = a.split("."), m = A(l, a), b = y + "." + p, x = I(H(d)), P = await crypto.subtle.importKey("spki", w(o), i, !1, ["verify"]);
      if (await O(n, P, b, x))
        return m.payload;
      throw u;
    }
  };
}
function h(e, t) {
  let { privkey: r, pubkey: o, expires: s, ...c } = t, { header: l, config: f } = v("ES", e, c), n = {
    name: "ECDSA",
    namedCurve: `P-${e}`
  }, i = {
    name: "ECDSA",
    hash: `SHA-${e}`
  };
  return {
    async sign(a) {
      let y = await crypto.subtle.importKey("pkcs8", w(r), n, !1, ["sign"]), p = k(l, { ...f, ...a }, s), d = await W(i, y, p);
      return p + "." + E(d);
    },
    async verify(a) {
      let [y, p, d] = a.split("."), m = A(l, a), b = y + "." + p, x = I(H(d)), P = await crypto.subtle.importKey("spki", w(o), n, !1, ["verify"]);
      if (await O(i, P, b, x))
        return m.payload;
      throw u;
    }
  };
}

// packages/worktop/src/jwt.ts
var V = /* @__PURE__ */ S.bind(0, "256"), X = /* @__PURE__ */ S.bind(0, "384"), _ = /* @__PURE__ */ S.bind(0, "512"), q = /* @__PURE__ */ g.bind(0, "256"), z = /* @__PURE__ */ g.bind(0, "384"), G = /* @__PURE__ */ g.bind(0, "512"), Q = /* @__PURE__ */ h.bind(0, "256"), Y = /* @__PURE__ */ h.bind(0, "384"), ee = /* @__PURE__ */ h.bind(0, "512");


exports.ES256 = Q;
exports.ES384 = Y;
exports.ES512 = ee;
exports.EXPIRED = C;
exports.HS256 = V;
exports.HS384 = X;
exports.HS512 = _;
exports.INVALID = u;
exports.RS256 = q;
exports.RS384 = z;
exports.RS512 = G;
exports.decode = T;