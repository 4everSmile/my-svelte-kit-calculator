// packages/worktop/src/router.ts
import { parse as d } from "regexparam";
import { finalize as m, STATUS_CODES as y } from "worktop/response";
function R(...s) {
  return async function(i, p) {
    let t, r;
    for (t of s)
      if (r = await t(i, p))
        return r;
  };
}
function h(s, i, p) {
  let t = {}, r, o, n, e, a;
  if (o = s[i]) {
    if (r = o.__s[p])
      return { params: t, handler: r.handler };
    for ([n, e] of o.__d)
      if (a = n.exec(p), a !== null) {
        if (a.groups !== void 0)
          for (r in a.groups)
            t[r] = a.groups[r];
        else if (e.keys.length > 0)
          for (r = 0; r < e.keys.length; )
            t[e.keys[r++]] = a[r];
        return { params: t, handler: e.handler };
      }
  }
}
function _() {
  let s, i, p = {};
  return s = {
    add(t, r, o) {
      let n = p[t];
      if (n === void 0 && (n = p[t] = {
        __d: new Map(),
        __s: {}
      }), r instanceof RegExp)
        n.__d.set(r, { keys: [], handler: o });
      else if (/[:|*]/.test(r)) {
        let { keys: e, pattern: a } = d(r);
        n.__d.set(a, { keys: e, handler: o });
      } else
        n.__s[r] = { keys: [], handler: o };
    },
    mount(t, r) {
      i = i || {}, i[t] = r.run;
    },
    onerror(t, r) {
      let { error: o, status: n = 500 } = r, e = o && o.message || y[n];
      return new Response(e || String(n), { status: n });
    },
    async run(t, r) {
      try {
        var o, n = [];
        r = r || {}, r.url = new URL(t.url), r.defer = (u) => {
          n.push(u);
        }, r.bindings = r.bindings || {};
        var e = s.prepare && await s.prepare(t, r);
        if (e && e instanceof Response)
          return e;
        let a, f = r.url.pathname, l = f + "/";
        if (i && f.length > 1) {
          for (a in i)
            if (l.startsWith(a))
              return r.url.pathname = f.substring(a.length) || "/", e = await i[a](new Request(r.url.href, t), r);
        }
        if (a = h(p, t.method, f), !a)
          return r.status = 404, e = await s.onerror(t, r);
        r.params = a.params, e = await a.handler(t, r);
      } catch (a) {
        r.status = 500, r.error = a, e = await s.onerror(t, r);
      } finally {
        for (e = new Response(e ? e.body : "OK", e); o = n.pop(); )
          await o(e);
        return m(e, t.method === "HEAD");
      }
    }
  };
}
export {
  _ as Router,
  R as compose
};
